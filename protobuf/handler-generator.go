package protobuf

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"google.golang.org/protobuf/compiler/protogen"
	"io"
	"os"
	"strings"
)

// https://github.com/grpc/grpc-go/blob/master/cmd/protoc-gen-go-grpc/grpc.go#L215

// GenerateHandlerFile generates handler to be implemented.
func GenerateHandlerFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_handler.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	prevFile, err := os.Open(filename)

	defer prevFile.Close()
	exist := err == nil
	if exist {
		src, err := os.ReadFile(filename)
		if err != nil {
			panic(err)
		}

		addHandlerToFile(src, g, file)

		return nil

	} else {

		return generateNewHandlerFile(g, file)
	}

}

func addHandlerToFile(src []byte, g *protogen.GeneratedFile, file *protogen.File) *protogen.GeneratedFile {
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", src, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "===panic====\n\n%s\n\n====panic===", src)
		panic(err)
	}

	//TODO: remember src index ,so we don't need to parse ast again
	//var index = make([]int, len(src))
	//for i, _ := range index {
	//	index[i] = i
	//}

	//create client
	for _, srv := range file.Services {

	MethodLoop:
		for methodIndex, method := range srv.Methods {
			for _, d := range astFile.Decls {
				if genDecl, ok := d.(*ast.FuncDecl); ok &&
					isMethod(genDecl, method.GoName, srv.GoName) { //method already exists

					inputs := getFuncParamTypes(genDecl)
					outputs := getFuncResultTypes(genDecl)

					if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() { //not stream
						if len(inputs) > 0 && inputs[len(inputs)-1] == "*"+method.Input.GoIdent.GoName {

							if len(outputs) > 0 && outputs[0] == "*"+method.Output.GoIdent.GoName {
								continue MethodLoop
							}
						}

						goto Generate
					}

					if method.Desc.IsStreamingClient() { // client ony have xxxServer param
						if len(inputs) > 0 && inputs[len(inputs)-1] == method.Parent.GoName+"_"+method.GoName+"Server" {
							continue MethodLoop
						}
						goto Generate
					}

					if method.Desc.IsStreamingServer() || !method.Desc.IsStreamingClient() { //server have two param, xxxrequest and xxxServer
						if len(inputs) > 1 &&
							inputs[len(inputs)-2] == "*"+g.QualifiedGoIdent(method.Input.GoIdent) &&
							inputs[len(inputs)-1] == method.Parent.GoName+"_"+method.GoName+"Server" {
							continue MethodLoop
						}
					}

				Generate:

					//continue MethodLoop

					// replace signature

					buff := bytes.NewBuffer(make([]byte, 0))

					buff.Write(src[:genDecl.Pos()-1]) //position before "func"

					// find line end
					var end = int(genDecl.Pos())
					for ; end < len(src); end++ {
						if src[end] == byte('\n') {
							break
						}
					}

					//fmt.Fprintf(os.Stderr, "\n\n===replace====%s==replace===== \n\n", method.GoName)

					FPrint(buff, g, "func ", serverSignature(g, method), " { //signature replaced by mesh-gen due to proto change")
					buff.Write(src[end:])

					// 修改数据后长度会变，需要重新解析语法树 , 否则需要记录每次插入的长度
					addHandlerToFile(buff.Bytes(), g, file)
					return g

				}
			}

			//method do not exist, generate and insert

			//fmt.Fprintf(os.Stderr, "\n\n===generate====%s==generate===== \n\n", method.GoName)

			//find next method position
			var insertPosition = len(src)
			if len(srv.Methods) != methodIndex+1 {
			SearchNext:
				for _, d := range astFile.Decls {
					if genDecl, ok := d.(*ast.FuncDecl); ok {
						if isMethod(genDecl, srv.Methods[methodIndex+1].GoName, srv.GoName) {
							if genDecl.Doc != nil {
								fmt.Fprintf(os.Stderr, "\n\n$$$found doc %d $$$$ \n\n", genDecl.Doc.Pos())
								insertPosition = int(genDecl.Doc.Pos())
								break SearchNext
							}
							fmt.Fprintf(os.Stderr, "\n\n$$$not found doc %d $$$$ \n\n", genDecl.Pos()-1)
							insertPosition = int(genDecl.Pos() - 1)
							break SearchNext
						}
					}
				}
			}

			// insert into insertPosition

			buff := bytes.NewBuffer(make([]byte, 0))

			buff.Write(src[:insertPosition])

			generateMethod(buff, g, srv, method)

			buff.Write(src[insertPosition:])

			// 修改数据后长度会变，需要重新解析语法树 , 否则需要记录每次插入的长度
			addHandlerToFile(buff.Bytes(), g, file)
			return g

		}

	}

	g.Write(src)
	return g

}

func generateNewHandlerFile(g *protogen.GeneratedFile, file *protogen.File) *protogen.GeneratedFile {
	g.P("// Code generated by protoc-gen-go-kit-grpc.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P(`import(
	"context"
`)
	g.P("pb ", g.QualifiedGoIdent(file.GoImportPath.Ident(strings.Replace(file.GoImportPath.String(), ".", string(file.GoPackageName), 1))))
	g.P(")")

	//create client
	for _, srv := range file.Services {
		g.P("type ", srv.GoName, " struct {")
		g.P("	pb.Unimplemented", srv.GoName, "Server")
		g.P("}")

		for _, method := range srv.Methods {

			var buf bytes.Buffer
			generateMethod(&buf, g, srv, method)
			buf.WriteTo(g)

		}
	}

	return g
}

func generateMethod(buf *bytes.Buffer, g *protogen.GeneratedFile, srv *protogen.Service, method *protogen.Method) {
	g.Annotate(srv.GoName+"."+method.GoName, method.Location)

	FPrint(buf, g, method.Comments.Leading,
		"func ", serverSignature(g, method), " {")

	FPrint(buf, g, "//TODO:implement")
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		FPrint(buf, g, "return nil, nil")
	} else {
		FPrint(buf, g, "return nil")
	}

	FPrint(buf, g, "}")

}

func serverSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "ctx context.Context")
		ret = "(*pb." + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "req "+"*pb."+g.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, "stream pb."+method.Parent.GoName+"_"+method.GoName+"Server")
	}

	g.P()
	prefix := "(e *" + method.Parent.GoName + ")" + method.GoName

	return prefix + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}

func FPrint(buf io.Writer, g *protogen.GeneratedFile, v ...interface{}) {
	for _, x := range v {
		switch x := x.(type) {
		case protogen.GoIdent:
			fmt.Fprint(buf, g.QualifiedGoIdent(x))
		default:
			fmt.Fprint(buf, x)
		}
	}

	fmt.Fprintln(buf)
}
