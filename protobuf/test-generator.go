package protobuf

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"os"
)

// GenerateTestFile generates go test file to test service client methods.
func GenerateTestFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_test.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	prevFile, err := os.Open(filename)

	defer prevFile.Close()
	exist := err == nil
	if exist {
		src, err := os.ReadFile(filename)
		if err != nil {
			panic(err)
		}

		addTestToFile(src, g, file)

		return nil

	} else {

		return generateNewTestFile(g, file)
	}
}

func addTestToFile(src []byte, g *protogen.GeneratedFile, file *protogen.File) *protogen.GeneratedFile {
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", src, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "===panic====\n\n%s\n\n====panic===", src)
		panic(err)
	}

	//TODO: 标记index 代替递归
	//var index = make([]int, len(src))
	//for i, _ := range index {
	//	index[i] = i
	//}

	//create client
	for _, srv := range file.Services {

	MethodLoop:
		for methodIndex, method := range srv.Methods {
			for _, d := range astFile.Decls {
				if genDecl, ok := d.(*ast.FuncDecl); ok &&
					isFunc(genDecl, "Test"+srv.GoName+"_"+method.GoName) { //method already exists
					continue MethodLoop
				}
			}

			//method do not exist

			//TODO: find next method position

			fmt.Fprintf(os.Stderr, "\n\n===generate====%s==generate===== \n\n", method.GoName)

			var insertPosition = len(src)

			if len(srv.Methods) != methodIndex+1 {
			SearchNext:
				for _, d := range astFile.Decls {
					if genDecl, ok := d.(*ast.FuncDecl); ok {
						if isFunc(genDecl, "Test"+srv.GoName+"_"+srv.Methods[methodIndex+1].GoName) {
							if genDecl.Doc != nil {
								//fmt.Fprintf(os.Stderr, "\n\n$$$found doc %d $$$$ \n\n", genDecl.Doc.Pos())
								insertPosition = int(genDecl.Doc.Pos())
								break SearchNext
							}
							//fmt.Fprintf(os.Stderr, "\n\n$$$not found doc %d $$$$ \n\n", genDecl.Pos()-1)
							insertPosition = int(genDecl.Pos() - 1)
							break SearchNext
						}
					}
				}
			}

			//TODO: insert into insertPosition

			buff := bytes.NewBuffer(make([]byte, 0))

			buff.Write(src[:insertPosition])

			generateTestFunc(buff, g, srv, method)

			buff.Write(src[insertPosition:])

			// 修改数据后长度会变，需要重新解析语法树 , 否则需要记录每次插入的长度
			addTestToFile(buff.Bytes(), g, file)
			return g

		}

	}

	g.Write(src)

	return g
}

func generateNewTestFile(g *protogen.GeneratedFile, file *protogen.File) *protogen.GeneratedFile {
	g.P("// Code generated by protoc-gen-go-kit-grpc.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	g.P(`import (
	context "context"
	log "log"
	testing "testing"
)
`)

	//create client
	for _, srv := range file.Services {
		for _, method := range srv.Methods {

			var buf = bytes.NewBuffer(make([]byte, 0))

			generateTestFunc(buf, g, srv, method)
			buf.WriteTo(g)

		}

	}

	return g
}

func generateTestFunc(buf *bytes.Buffer, g *protogen.GeneratedFile, srv *protogen.Service, method *protogen.Method) {

	FPrint(buf, g, "func Test", srv.GoName, "_", method.GoName, "(t *", "testing.T", ") {")

	FPrint(buf, g, "client := GetNew", srv.GoName, "Client()")

	if !method.Desc.IsStreamingClient() {
		FPrint(buf, g, "rsp, err := client.", method.GoName, "(", "context.TODO()", ", &", method.Input.GoIdent.GoName, "{")

		for _, field := range method.Input.Fields {
			fillFiled(buf, g, field)
		}
		FPrint(buf, g, "})")
	} else {
		FPrint(buf, g, "rsp, err := client.", method.GoName, "(", "context.TODO() )")

	}

	FPrint(buf, g, `if err != nil {
	t.Error(err)
	return
}`)

	FPrint(buf, g, "log.Printf", "(\"rsp: %v\", rsp)")

	FPrint(buf, g, "}")
}

func fillFiled(buf *bytes.Buffer, g *protogen.GeneratedFile, field *protogen.Field) {
	if field.Message != nil {
		FPrint(buf, g, field.GoName, ": &", field.GoName, "{")

		for _, field := range field.Message.Fields {
			fillFiled(buf, g, field)
		}

		FPrint(buf, g, "},")

	} else {
		FPrint(buf, g, "\t", field.GoName, ": ", getDefaultValue(field), ",")
	}

}

func getDefaultValue(field *protogen.Field) string {

	if field.Desc.HasOptionalKeyword() {
		return "new(" + getGolangType(field) + ")"
	}

	if field.Desc.Cardinality() == protoreflect.Repeated {
		return "[]" + getGolangType(field) + "{}"
	}

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "false"
	case protoreflect.EnumKind:
		return removeAfterUnderline(field.Enum.GoIdent.GoName) + "_" + string(field.Enum.Values[0].Desc.Name())
	case protoreflect.Int32Kind:
		return "0"
	case protoreflect.Sint32Kind:
		return "0"
	case protoreflect.Uint32Kind:
		return "0"
	case protoreflect.Int64Kind:
		return "0"
	case protoreflect.Sint64Kind:
		return "0"
	case protoreflect.Uint64Kind:
		return "0"
	case protoreflect.Sfixed32Kind:
		return "nil"
	case protoreflect.Fixed32Kind:
		return "0"
	case protoreflect.FloatKind:
		return "0.0"
	case protoreflect.Sfixed64Kind:
		return "0"
	case protoreflect.Fixed64Kind:
		return "0"
	case protoreflect.DoubleKind:
		return "0.0"
	case protoreflect.StringKind:
		return "\"string\""
	case protoreflect.BytesKind:
		return "[]byte{}"
	case protoreflect.MessageKind:
		return "nil"
	case protoreflect.GroupKind:
		return "nil"
	}
	return ""
}

func getGolangType(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.EnumKind:
		return field.Enum.GoIdent.GoName
	case protoreflect.Int32Kind:
		return "int32"
	case protoreflect.Sint32Kind:
		return "int32"
	case protoreflect.Uint32Kind:
		return "uint32"
	case protoreflect.Int64Kind:
		return "int64"
	case protoreflect.Sint64Kind:
		return "int64"
	case protoreflect.Uint64Kind:
		return "uint64"
	case protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Fixed32Kind:
		return "int32"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Fixed64Kind:
		return "int64"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	case protoreflect.MessageKind:
		return field.GoName
	case protoreflect.GroupKind:
		return field.GoName
	}
	return ""
}

func removeAfterUnderline(name string) string {

	for i := len(name) - 1; i >= 0; i-- {
		if name[i] == '_' {
			return name[:i]
		}
	}

	return name
}
